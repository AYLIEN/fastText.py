# fastText C++ interface
from interface cimport loadModelWrapper
from interface cimport FastTextModel

# Python/C++ standart libraries
from libc.stdlib cimport malloc, free
from libcpp.string cimport string
from libcpp.vector cimport vector

# Python module
import os
from model import SupervisedModel
from builtins import bytes

# This class wrap C++ class FastTextModel, so it can be accessed via Python
cdef class FastTextModelWrapper:
    cdef FastTextModel fm

    def __cinit__(self):
        self.fm = FastTextModel()

    # dict_* methods is a wrapper for the Dictionary class methods;
    # We can't access dicrectly Dictionary in python because
    # Dictionary class doesn't have a nullary constructor
    def dict_nwords(self):
        return self.fm.dictGetNWords()

    def dict_get_word(self, i, encoding):
        cdef string cpp_string
        cpp_string = self.fm.dictGetWord(i)
        return cpp_string.decode(encoding)

    def dict_nlabels(self):
        return self.fm.dictGetNLabels()

    def dict_get_label(self, i, encoding):
        cdef string cpp_string
        cpp_string = self.fm.dictGetLabel(i)
        return cpp_string.decode(encoding)

    def classifier_predict_prob(self, text, k, label_prefix, encoding):
        cdef vector[vector[string]] raw_results
        cdef string cpp_str
        text_bytes = bytes(text, encoding)
        labels = []
        probabilities = []
        raw_results = self.fm.classifierPredictProb(text_bytes, k)
        for result in raw_results:
            cpp_str = result[0]
            label = cpp_str.decode(encoding)
            label = label.replace(label_prefix, '')
            cpp_str = result[1]
            prob = float(cpp_str)
            labels.append(label)
            probabilities.append(prob)
        return list(zip(labels, probabilities))

    @property
    def dim(self):
        return self.fm.dim

    @property
    def ws(self):
        return self.fm.ws

    @property
    def epoch(self):
        return self.fm.epoch

    @property
    def minCount(self):
        return self.fm.minCount

    @property
    def neg(self):
        return self.fm.neg

    @property
    def wordNgrams(self):
        return self.fm.wordNgrams

    @property
    def lossName(self):
        return self.fm.lossName

    @property
    def modelName(self):
        return self.fm.modelName

    @property
    def bucket(self):
        return self.fm.bucket

    @property
    def minn(self):
        return self.fm.minn

    @property
    def maxn(self):
        return self.fm.maxn

    @property
    def lrUpdateRate(self):
        return self.fm.lrUpdateRate

    @property
    def neg(self):
        return self.fm.neg

    @property
    def t(self):
        return self.fm.t

# Load .bin file that generated by fastText
# label_prefix is an optional argument to load the supervised model
# prefix will be removed from the label name and stored in the model.labels
def load_model(filename, label_prefix='', encoding='utf-8'):
    # Check if the filename is readable
    if not os.path.isfile(filename):
        raise ValueError('fastText: trained model cannot be opened!')

    model = FastTextModelWrapper()
    filename_bytes = bytes(filename, encoding)
    try:
        # How we load the dictionary
        loadModelWrapper(filename_bytes, model.fm)
    except:
        raise Exception('fastText: Cannot load ' + filename +
                ' due to C++ extension failed to allocate the memory')

    model_name = model.fm.modelName
    if model_name == 'supervised':
        labels = []
        for i in xrange(model.dict_nlabels()):
            label = model.dict_get_label(i, encoding)
            # Remove the prefix
            labels.append(label.replace(label_prefix, ''))
        return SupervisedModel(model, labels, label_prefix, encoding)
    else:
        raise ValueError('fastText: model name is not valid!')
