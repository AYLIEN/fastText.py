# fastText C++ interface
from interface cimport trainWrapper
from interface cimport loadModelWrapper
from interface cimport FastTextModel
from interface cimport callbackfunc

# Python/C++ standart libraries
from libc.stdlib cimport malloc, free
from libcpp.string cimport string
from libcpp.vector cimport vector

# Python module
import os
from model import SupervisedModel
from builtins import bytes

# This class wrap C++ class FastTextModel, so it can be accessed via Python
cdef class FastTextModelWrapper:
    cdef FastTextModel fm

    def __cinit__(self):
        self.fm = FastTextModel()

    def classifier_predict_prob(self, text, k, label_prefix, encoding):
        cdef vector[vector[string]] raw_results
        cdef string cpp_str
        text_bytes = bytes(text, encoding)
        labels = []
        probabilities = []
        raw_results = self.fm.classifierPredictProb(text_bytes, k)
        for result in raw_results:
            cpp_str = result[0]
            label = cpp_str.decode(encoding)
            label = label.replace(label_prefix, '')
            cpp_str = result[1]
            prob = float(cpp_str)
            labels.append(label)
            probabilities.append(prob)
        return list(zip(labels, probabilities))


# Load .bin file that generated by fastText
# label_prefix is an optional argument to load the supervised model
# prefix will be removed from the label name and stored in the model.labels
def load_model(filename, label_prefix='', encoding='utf-8'):
    # Check if the filename is readable
    if not os.path.isfile(filename):
        raise ValueError('fastText: trained model cannot be opened!')

    model = FastTextModelWrapper()
    filename_bytes = bytes(filename, encoding)
    try:
        # How we load the dictionary
        loadModelWrapper(filename_bytes, model.fm)
    except:
        raise Exception('fastText: Cannot load ' + filename +
                ' due to C++ extension failed to allocate the memory')

    return SupervisedModel(model, label_prefix, encoding)


# Wrapper for train(int argc, char *argv) C++ function in cpp/src/fasttext.cc
def train_wrapper(model_name, input_file, output, label_prefix, lr, dim, ws,
        epoch, min_count, neg, word_ngrams, loss, bucket, minn, maxn, thread,
        lr_update_rate, t, pretrained_vectors, callback, silent=1, encoding='utf-8'):

    # Check if the input_file is valid
    if not os.path.isfile(input_file):
        raise ValueError('fastText: cannot load ' + input_file)

    # Check if the output is writeable
    try:
        f = open(output, 'w')
        f.close()
        os.remove(output)
    except IOError:
        raise IOError('fastText: output is not writeable!')

    # Setup argv, arguments and their values
    py_argv = [b'fasttext', bytes(model_name, 'utf-8')]
    py_args = [b'-input', b'-output', b'-lr', b'-dim', b'-ws', b'-epoch',
            b'-minCount', b'-neg', b'-wordNgrams', b'-loss', b'-bucket',
            b'-minn', b'-maxn', b'-thread', b'-lrUpdateRate', b'-t']
    values = [input_file, output, lr, dim, ws, epoch, min_count, neg,
            word_ngrams, loss, bucket, minn, maxn, thread, lr_update_rate, t]

    # Add -label and -pretrainedVectors params for supervised model
    if model_name == 'supervised':
        py_args.append(b'-label')
        values.append(label_prefix)
        py_args.append(b'-pretrainedVectors')
        values.append(pretrained_vectors)

    for arg, value in zip(py_args, values):
        py_argv.append(arg)
        py_argv.append(bytes(str(value), 'utf-8'))
    argc = len(py_argv)

    # Converting Python object to C++
    cdef int c_argc = argc
    cdef char **c_argv = <char **>malloc(c_argc * sizeof(char *))
    for i, arg in enumerate(py_argv):
        c_argv[i] = arg

    # Run the train wrapper
    trainWrapper(c_argc, c_argv, silent, callback_run, <void*> callback)

    # Load the model
    output_bin = output + '.bin'
    model = load_model(output_bin, label_prefix, encoding=encoding)

    # Free the allocated memory
    # The content from PyString_AsString is not deallocated
    free(c_argv)

    return model

# Train classifier
def supervised(input_file, output, callback, label_prefix='__label__', lr=0.1, dim=100,
        ws=5, epoch=5, min_count=1, neg=5, word_ngrams=1, loss='softmax',
        bucket=0, minn=0, maxn=0, thread=12, lr_update_rate=100,
        t=1e-4, pretrained_vectors='', silent=1, encoding='utf-8'):
    return train_wrapper('supervised', input_file, output, label_prefix, lr,
            dim, ws, epoch, min_count, neg, word_ngrams, loss, bucket, minn,
            maxn, thread, lr_update_rate, t, pretrained_vectors, callback, silent, encoding)

cdef void callback_run(double progress, void *f):
    (<object>f)(progress)